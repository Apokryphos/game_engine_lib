#pragma once

#include "render/model_batch.hpp"
#include "render/renderer.hpp"
#include "render_vk/billboard_pipeline.hpp"
#include "render_vk/descriptor_sets.hpp"
#include "render_vk/depth.hpp"
#include "render_vk/dynamic_uniform_buffer.hpp"
#include "render_vk/sprite_pipeline.hpp"
#include "render_vk/uniform_buffer.hpp"
#include "render_vk/vulkan.hpp"
#include "render_vk/vulkan_swapchain.hpp"
#include <map>
#include <mutex>
#include <queue>
#include <thread>
#include <vector>

struct GLFWwindow;

namespace render_vk
{
class ModelManager;
class VulkanModelRenderer;

class VulkanRenderSystem : public render::Renderer
{
public:
    enum class FrameTaskId
    {
        None,
        DrawBillboards,
        DrawModels,
        DrawSprites,
        UpdateFrameUniforms,
        UpdateObjectUniforms,
    };

    struct FrameDescriptorObjects
    {
        //  The descriptor pool for this frame.
        VkDescriptorPool pool      = VK_NULL_HANDLE;
        //  The per-frame descriptor set for this frame.
        VkDescriptorSet frame_set  = VK_NULL_HANDLE;
        //  The per-object descriptor set for this frame.
        // VkDescriptorSet object_set = VK_NULL_HANDLE;
        //  The texture array descriptor set for this frame.
        VkDescriptorSet texture_set = VK_NULL_HANDLE;
    };

    struct FrameCommandObjects
    {
        //  The command pool for this frame.
        VkCommandPool pool       = VK_NULL_HANDLE;
        //  The secondary command buffer for this frame.
        VkCommandBuffer buffer   = VK_NULL_HANDLE;
    };

    struct FrameSyncObjects
    {
        //  Swapchain image is acquired.
        VkSemaphore image_acquired       = VK_NULL_HANDLE;
        //  Command buffers are finished processing.
        VkSemaphore present_ready        = VK_NULL_HANDLE;
        //  This frame is complete and resources can be reused.
        VkFence frame_complete           = VK_NULL_HANDLE;
    };

    //  Frame objects for main thread
    struct Frame
    {
        FrameSyncObjects sync;
        FrameCommandObjects command;
    };

    //  Frame objects for worker threads
    struct ThreadFrame
    {
        FrameCommandObjects command;
        FrameDescriptorObjects descriptor;
    };

    struct Job
    {
        FrameTaskId task_id {FrameTaskId::None};
        uint32_t order      {0};
        void* args          {nullptr};

        FrameUbo frame_ubo;
        std::vector<render::ModelBatch> batches;
        std::vector<render::SpriteBatch> sprite_batches;
    };

    enum class FrameStatus
    {
        None,
        //  Waiting for render threads to complete.
        Busy,
        //  Render threads are complete.
        Ready,
        //  Frame was discarded due to swapchain recreation or worker thread
        //  failure.
        Discarded,
    };

    class RenderTasks
    {
        struct TaskResults
        {
            uint32_t called;
            uint32_t complete;
        };

        uint32_t m_order {0};
        std::map<FrameTaskId, TaskResults> m_results;

        //  Secondary command buffers generated by worker threads
        //  stored in the order they were started.
        std::map<uint32_t, VkCommandBuffer> m_command_buffers;

    public:
        //  Returns the order of this call
        uint32_t add_call(FrameTaskId task_id) {
            TaskResults& results = m_results[task_id];
            ++results.called;

            return m_order++;
        }

        void add_results(
            FrameTaskId task_id,
            uint32_t order,
            VkCommandBuffer command_buffer
        ) {
            TaskResults& results = m_results[task_id];

            //  Only add command buffer if the task actually generates one.
            switch (task_id) {
                default:
                    throw std::runtime_error("Not implemented.");

                //  Tasks that do not generate secondary command buffers
                case FrameTaskId::UpdateObjectUniforms:
                case FrameTaskId::UpdateFrameUniforms:
                    break;

                //  Tasks that generate secondary command buffers
                case FrameTaskId::DrawBillboards:
                case FrameTaskId::DrawModels:
                case FrameTaskId::DrawSprites:
                    m_command_buffers[order] = command_buffer;
                    break;
            }

            ++results.complete;
        }

        void clear() {
            m_order = 0;
            m_results.clear();
            m_command_buffers.clear();
        }

        void get_command_buffers(
            std::vector<VkCommandBuffer>& command_buffers
        ) const {
            for (const auto& pair : m_command_buffers) {
                command_buffers.push_back(pair.second);
            }
        }

        bool is_complete() const {
            for (const auto& pair : m_results) {
                if (pair.second.called != pair.second.complete) {
                    return false;
                }
            }

            return true;
        }
    };

private:
    //  Status of current frame.
    FrameStatus m_frame_status          = FrameStatus::None;

    //  Cancel worker threads when true.
    bool m_cancel_threads               = false;
    //  Recreate swapchain objects when true.
    bool m_framebuffer_resized          = false;

    //  The total number of frames (resources).
    uint8_t m_frame_count               = 3;
    //  The current frame number (0...frame count).
    uint8_t m_current_frame             = 0;
    //  Number of worker threads.
    uint8_t m_thread_count              = 4;
    //  Swapchain image index
    uint32_t m_image_index              = 0;

    VkInstance m_instance               = VK_NULL_HANDLE;
    VkPhysicalDevice m_physical_device  = VK_NULL_HANDLE;
    VkDevice m_device                   = VK_NULL_HANDLE;
    VkSurfaceKHR m_surface              = VK_NULL_HANDLE;
    //  Presentation queue
    VkQueue m_present_queue             = VK_NULL_HANDLE;

    VkRenderPass m_render_pass          = VK_NULL_HANDLE;

    //  Command pool used to create main thread resources
    VkCommandPool m_resource_command_pool = VK_NULL_HANDLE;

    DescriptorSetLayouts m_descriptor_set_layouts;
    //  Debug messenger
    VkDebugUtilsMessengerEXT m_debug_messenger    = VK_NULL_HANDLE;

    GLFWwindow* m_glfw_window = nullptr;

    //  Graphics queue
    VulkanQueue m_graphics_queue;
    //  Swapchain
    VulkanSwapchain m_swapchain;
    //  Depth buffer image
    DepthImage m_depth_image;
    //  Per-frame uniform buffer
    UniformBuffer<FrameUbo> m_frame_uniform;
    //  Per-object dynamic uniform buffer
    DynamicUniformBuffer<ObjectUbo> m_object_uniform;

    SpritePipeline m_sprite_pipeline;
    BillboardPipeline m_billboard_pipeline;

    //  Main thread frame objects
    std::vector<Frame> m_frames;

    //  Worker threads
    std::vector<std::thread> m_threads;

    //  Job queue mutex
    std::mutex m_jobs_mutex;
    //  Job queue
    std::queue<Job> m_jobs;

    std::mutex m_tasks_mutex;
    //  Worker thread secondary commands output
    RenderTasks m_tasks;

    std::unique_ptr<ModelManager> m_model_mgr;
    std::unique_ptr<VulkanModelRenderer> m_model_renderer;

    //  Adds a new job for a worker thread to process.
    void add_job(Job& job);
    //  Stops worker threads.
    void cancel_threads();
    //  Checks the status of the current frame's rendering tasks.
    //  This function should only be called from end_frame.
    bool check_render_tasks_complete();
    //  Creates frame objects.
    void create_frame_resources();
    //  Creates swapchain and render pass.
    void create_swapchain_objects();
    void create_swapchain_dependents();
    void destroy_swapchain();
    void destroy_frame_resources();
    //  Checks if a worker thread job is available.
    bool get_job(Job& job);
    //  Called by worker threads when work is completed.
    void post_results(
        FrameTaskId task_id,
        uint32_t order,
        VkCommandBuffer comand_buffer
    );
    //  Recreates swapchain and dependent objects.
    void recreate_swapchain();
    //  Releases objects.
    void shutdown();
    //  Starts worker threads.
    void start_threads();
    //  Worker thread main function.
    void thread_main(uint8_t thread_id);

public:
    VulkanRenderSystem();
    ~VulkanRenderSystem();
    //  Starts a new frame.
    virtual void begin_frame() override;
    virtual void draw_billboards(
        std::vector<render::SpriteBatch>& batches
    ) override;
    virtual void draw_models(
        std::vector<render::ModelBatch>& batches
    ) override;
    virtual void draw_sprites(
        std::vector<render::SpriteBatch>& batches
    ) override;
    //  Presents the completed frame.
    virtual void end_frame() override;
    virtual float get_aspect_ratio() const override;
    virtual glm::vec2 get_size() const override;

    VkInstance get_instance() const {
        return m_instance;
    }

    //  Initializes objects.
    virtual bool initialize(GLFWwindow* glfw_window) override;
    virtual void load_model(
        common::AssetId id,
        const std::string& path
    ) override;
    virtual void load_texture(
        common::AssetId id,
        const std::string& path
    ) override;
    //  Framebuffer was resized
    virtual void resize() override;
    virtual void update_frame_uniforms(
        const glm::mat4& view,
        const glm::mat4& proj,
        const glm::mat4& ortho_view,
        const glm::mat4& ortho_proj
    ) override;
};
}
